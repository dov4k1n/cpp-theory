# Обработка исключений
М. А. Ложников, сентября 2021 г.

- [Обработка исключений](#обработка-исключений)
  - [Обработка ошибок в языке C](#обработка-ошибок-в-языке-c)
  - [Обработка ошибок при помощи исключений в C++](#обработка-ошибок-при-помощи-исключений-в-c)
    - [Пример](#пример)
  - [Создание собственных типов исключений](#создание-собственных-типов-исключений)
  - [Проброс исключения вверх по стеку](#проброс-исключения-вверх-по-стеку)
    - [Пример проброса исключения](#пример-проброса-исключения)
  - [Список литературы](#список-литературы)

## Обработка ошибок в языке C

Для обработки ошибок в языке C как правило используются возвращаемые значения функций или внешние переменные. Таким образом, программист каждый раз должен проверять возвращаемое значение каждой функции, которая может отработать с ошибкой.

```c
int ReadArray(FILE* fin, double* a, int n) {
  int i;

  for (i = 0; i < n; i++) {
    if (fscanf(fin, "%lf", a + i) != 1)
      return -1;
  }

  return 0;
}
```

Предположим, что функция `ReadArray()` вызывается в функции `foo()`, которая в свою очередь вызывается в функции `bar()`. В таком случае одну и ту же ошибку, связанную с чтением данных приходится проверять во всём стеке вызываемых функций.

```c
int foo() {
  if (ReadArray(...) < 0)
    return -1;

  return 0;
}

int bar() {
  if (foo() < 0)
    return -1;

  return 0;
}
```

Для того, чтобы избежать лишних проверок вручную, в языке C++ существует механизм исключений.

## Обработка ошибок при помощи исключений в C++

Исключение является объектом некоторого типа данных (тип данных может быть любым), который содержит в себе информацию об ошибке. Само исключение может быть сгенерировано (ещё говорят выброшено) функцией в результате какой-либо ошибки. Затем это исключение можно поймать в специальном обработчике и обработать ошибку должным образом. При генерации исключения выполнение программы сразу перемещается в соответствующий обработчик. При этом компилятор вызывает деструктор для всех объектов, которые пропали из области видимости при перемещении в обработчик. Если для исключения не назначен обработчик, то в случае его срабатывания программа вылетает.

Для генерации исключения используется ключевое слово `throw`, за которым следует сам объект (переменная), содержащий информацию об ошибке. При этом для того, чтобы исключение можно было перехватить, код, который потенциально может сгенерировать исключение должен находиться в специальном блоке `try`. Обработчик исключения пишется отдельно для каждого типа данных, объектом которого может являться исключение в специальном блоке `catch`, следующим сразу за соответствующим блоком `try`.

Таким образом, при генерации исключения программа сразу переходит из блока `try` в соответствующий обработчик (блок `catch`), если он есть. После обработки исключения в обработчике программа продолжает своё выполнение с места сразу после блоков `try/catch`.

```cpp
try {
  /* В блоке try пишется код программы, который может потенциально сгенерировать исключение. */

  int i = 0;

  std::cin >> i;

  if (i == 0) {
    // Генерируем исключение типа int.
    throw -1;
  } else if (i == 1) {
    // Генерируем исключение типа const char*.
    throw "Pointer to const char exception.";
  } else if (i == 2) {
    // Генерируем исключение типа std::string.
    throw std::string("std::string exception.");
  }
} 

catch (const ExceptionType1& exception1) {
  /* Обрабатываем исключение типа ExceptionType1. */
} 

catch (const ExceptionType2& exception2) {
  /* Обрабатываем исключение типа ExceptionType2. */
} 

catch (const ExceptionTypeN& exceptionN) {
  /* Обрабатываем исключение типа ExceptionTypeN. */
} 

catch (...) {
  /* Если в круглых скобках после catch указано многоточие, то такой обработчик будет обрабатывать любой тип исключения кроме перечисленных ранее. */
}

/* В случае если исключение не было сгенерировано, то этот код выполняется сразу после блока try. В противном случае этот код выполняется сразу после соответствующего обработчика исключения. */
```

Отметим, что в конструкции `try/catch` может быть выполнен только один обработчик. Сами обработчики должны располагаться в порядке от частного к общему.

### Пример

```cpp
#include <iostream>
#include <cmath>

double Divide(double left, double right) {
  if (std::fabs(right) < 1e-14) {
    /* Попытка деления на нуль. Генерируем исключение. */
    throw "Division by zero.";
  }

  /* Выполняем операцию деления. */
  return left / right;
}

int main() {
  double a, b, c = 0;

  std::cin >> a >> b;
  
  try {
    /* Исключение не обязательно нужно генерировать явно в блоке try. Оно может быть сгенерировано какой-либо функцией, вызывающейся в блоке try, и обработано в соответствующем ему блоке catch. */
    c = Divide(a, b);
  } 
  
  catch(const char* e) {
    /* Словили исключение. Выводим информацию о нём. */
    std::cout << "Got an exception. Reason: " << e << std::endl;
  }

  std::cout << "Result: " << c << std::endl;
  return 0;
}
```

## Создание собственных типов исключений

```cpp
#include <iostream>
#include <cstdio>
#include <stdexcept>

/* Специальный тип исключения для обработки ошибок ввода/вывода. */
class IOError {
 private:
  std::string reason;
 public:
  IOError(const std::string& reason) :
    reason(reason)
  { }

  const std::string& Reason() const { return reason; }
};

/* Специальный тип исключения для обработки ошибок, связанных с некорректными 18 значениями. */
class ValueError {
 private:
  std::string reason;
 public:
  ValueError(const std::string& reason) :
    reason(reason)
  { }
  
  const std::string& Reason() const { return reason; }
};

/* А это класс для чтения данных из файла. Класс в конструкторе открывает файл, а в деструкторе его самостоятельно закрывает. */
class FileReader {
 private:
  std::FILE* file;
 public:
  FileReader(const char* filename) :
    file(std::fopen(filename, "rt"))
  {
    if (!file) {
      /* Не смогли открыть файл. Выбрасываем исключение. */
      throw IOError("Can't open file");
    }
  }

  /* Удаляем конструктор копирования и операцию копирующего присваивания. */
  FileReader(const FileReader&) = delete;
  FileReader& operator=(const FileReader&) = delete;

  ~FileReader() {
    if (file)
      std::fclose(file);
  }

  double ReadDouble() const {
    double value;

    if (std::fscanf(file, "%lf", &value) != 1) {
      /* Не получилось считать значение. Генерируем исключение. */
      throw IOError("Can't read the next value.");
    }

    return value;
  }


  int ReadInt() const {
    int value;

    if (std::fscanf(file, "%d", &value) != 1) {
      /* Не получилось считать значение. Генерируем исключение. */
      throw IOError("Can't read the next value.");
    }

    return value;
  }
};

void ReadMatrix(
  const FileReader& reader, 
  double* matrix, 
  int numRows, 
  int numCols
) {
  for (int row = 0; row < numRows; row++) {
    for (int col = 0; col < numCols; col++) {
      /* Метод ReadDouble() может сгенерировать исключение IOError. */
      matrix[row * numCols + col] = reader.ReadDouble();
    }
  }
}

int main() {
  double* matrix = nullptr;

  try {
    /* Конструктор может сгенерировать исключение IOError. */
    FileReader reader("input.txt");

    /* Метод ReadInt() может сгенерировать исключение IOError. */
    int numRows = reader.ReadInt();
    int numCols = reader.ReadInt();

    if (numRows <= 0 || numCols <= 0) {
      throw ValueError("Incorrect matrix dimensions.");
    }

    /* Оператор new может сгенерировать исключение std::bad_alloc. */
    matrix = new double[numRows * numCols];

    /* Функция ReadMatrix() может сгенерировать исключение IOError. */
    ReadMatrix(reader, matrix, numRows, numCols);
  }

  catch (const IOError& e) {
    std::cout << "Input/output error. Reason: " << e.Reason() << std::endl;
  } 
  
  catch (const ValueError& e) {
    std::cout << "Value error. Reason: " << e.Reason() << std::endl;
  } 
  
  catch (const std::bad_alloc& e) {
    /* Исключение типа std::bad_alloc из заголовочного файла <stdexcept> генерирует
    оператор new в случае ошибки выделения памяти. */
    std::cout << "Can't allocate memory! Reason: " << e.what() << std::endl;
  }

  if (matrix)
    delete[] matrix;
  
  return 0;
}
```

> **Замечание:** 
> 
> В примере выше возвращаемое значение оператора `new` не проверяется, поскольку в случае ошибки выделения памяти оператор `new` генерирует исключение `std::bad_alloc` из заголовочного файла `<stdexcept>`. Таким образом, оператор `new` в C++ никогда не возвращает значение `nullptr`.

## Проброс исключения вверх по стеку

В некоторых случаях возникает необходимость поймать исключение в обработчике, а затем передать это исключение дальше в следующий обработчик (если он есть). Речь идёт о ситуации, когда в некотором внешнем блоке `try` написана группа внутренних блоков `try/catch`. Для проброса исключения из внутреннего обработчика во внешний нужно написать конструкцию `throw;` (без аргумента) в соответствующем внутреннем обработчике.

```cpp
try {
  try {
    int i = 0;

    std::cin >> i;

    if (i == 0) {
      throw -101;
    }
  } 
  
  catch (int code) {
    std::cout << "Got an exception for the first time. Code = " << code << std::endl;

    /* Пробрасываем исключение во внешний обработчик. */
    throw;
  }
} 

catch(int code) {
  /* Ловим исключение второй раз. */
  std::cout << "The same exception. Again! Code = " << code << std::endl;
}
```

### Пример проброса исключения

Рассмотрим пример, в котором перехват исключения внутри функции необходим для корректного
закрытия файла.

```cpp
#include <iostream>
#include <cstdio>

/* Функция читает целое число из заранее открытого файла. В случае ошибки генерируется исключение. */
int DoRead(std::FILE* file) {
  int value;

  if (std::fscanf(file, "%d", &value) != 1) {
    /* Не получилось считать число. Генерируем исключение. */
    throw std::string("Can't read value.");
  }

  return value;
}

int ReadIntFromFile(const char* filename) {
  std::FILE* file = std::fopen(filename, "rt");
  int value = 0;

  if (!file) {
    /* Не открылся файл. Выбрасываем исключение. */
    throw std::string("Can't open file!");
  }

  try {
    /* Функция Dod() может сгенерировать исключение. Если его не обработать внутри текущей функции, то файл останется открыт. */
    value = DoRead(file);
  } 
  
  catch (const std::string& e) {
    /* Не получилось считать данные из файла. Нужно закрыть файл, а затем пробросить исключение вверх по стеку. */
    std::fclose(file);

    /* Пробрасываем исключение вверх по стеку. */
    throw;
  }

  /* Если функция DoRead() выбрасывает исключение, то этот код не выполняется. 
  Таким образом, файл мог бы остаться открытым, если бы не был написан правильный обработчик. */
  std::fclose(file);

  return value;
}

int main() {
  try {
    int value = ReadIntFromFile("input.txt");

    std::cout << "Value: " << value << std::endl;
  } 
  
  catch (const std::string& e) {
    std::cout << "Got an exception. Reason: " << e << std::endl;
  }

  return 0;
}
```

> **Замечание.**
> 
> Отметим, что в предыдущем примере данная проблема решается при  помощи специального класса, который закрывает файл в деструкторе. Напомним, что при генерации исключения, деструктор вызывается у всех объектов, которые пропадают из области видимости при переходе в обработчик. По этой причине (и не только) в современном C++ не рекомендуется пользоваться сырыми указателями, обычными файлами из языка C, а так же всем тем, что требует ручного освобождения памяти. Вместо этого в стандартной библиотеке C++ есть специальные классы-оболочки над динамическим массивом (шаблон `std::vector`), над файлом (`std::ifstream` и `std::ofstream`), а также над обычным указателем (шаблоны `std::unique_ptr`, `std::shared_ptr` и не только).


## Список литературы

[1] Бьерн Страуструп Язык программирования C++. М:Бином. 2011.

[2] https://en.cppreference.com

[3] https://en.cppreference.com/w/cpp/language/throw

[4] https://en.cppreference.com/w/cpp/language/try_catch