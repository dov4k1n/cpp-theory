https://phys.bspu.by/static/um/inf/prg/sem3/book/book_c/

# Статические функции и элементы данных

- [Статические функции и элементы данных](#статические-функции-и-элементы-данных)
  - [СОВМЕСТНОЕ ИСПОЛЬЗОВАНИЕ ЭЛЕМЕНТА ДАННЫХ](#совместное-использование-элемента-данных)
    - [Совместное использование элементов класса](#совместное-использование-элементов-класса)
    - [Использование элементов с атрибутами `public static`, если объекты не существуют](#использование-элементов-с-атрибутами-public-static-если-объекты-не-существуют)
  - [ИСПОЛЬЗОВАНИЕ СТАТИЧЕСКИХ ФУНКЦИЙ-ЭЛЕМЕНТОВ](#использование-статических-функций-элементов)
  - [ЧТО ВАМ НЕОБХОДИМО ЗНАТЬ](#что-вам-необходимо-знать)

До настоящего момента каждый создаваемый вами объект имел свой собственный набор элементов данных.

В зависимости от назначения вашего приложения могут быть ситуации, когда объекты одного и того же класса должны совместно использовать один или несколько элементов данных.

Например, предположим, что вы пишете программу платежей, которая отслеживает рабочее время для 1000 служащих. Для определения налоговой ставки программа должна знать условия, в которых работает каждый служащий. Пусть для этого используется переменная класса `state_of_work`. Однако, если все служащие работают в одинаковых условиях, ваша программа могла бы совместно использовать этот элемент данных для всех объектов типа employee. Таким образом, ваша программа уменьшает необходимое количество памяти, выбрасывая 999 копий одинаковой информации.

Для совместного использования элемента класса вы должны объявить этот элемент как `static` (статический).

Этот урок рассматривает шаги, которые вы должны выполнить для совместного использования элемента класса несколькими объектами.

К концу этого урока вы освоите следующие основные концепции:

* C++ позволяет иметь объекты одного и того же типа, которые совместно используют один или несколько элементов класса. 

* Если ваша программа присваивает значение совместно используемому элементу, то все объекты этого класса сразу же получают доступ к этому новому значению. 

* Для создания совместно используемого элемента данных класса вы должны предварять имя элемента класса ключевым словом `static`. 

* После того как программа объявила элемент класса как `static`, она должна объявить глобальную переменную (вне определения класса), которая соответствует этому совместно используемому элементу класса. 

* Ваши программы могут использовать ключевое слово `static`, чтобы сделать метод класса вызываемым в то время, как программа, возможно, еще не объявила каких-либо объектов данного класса. 

## СОВМЕСТНОЕ ИСПОЛЬЗОВАНИЕ ЭЛЕМЕНТА ДАННЫХ

Обычно, когда вы создаете объекты определенного класса, каждый объект получает свой собственный набор элементов данных. Однако возможны такие ситуации, при которых объектам одного и того же класса необходимо совместно использовать один или несколько элементов данных (статические элементы данных). В таких случаях объявляйте элементы данных как общие или частные, а затем предваряйте тип ключевым словом static, как показано ниже:

```c++
 private:
  static int shared_value;
```

После объявления класса вы должны объявить элемент как глобальную переменную вне класса, как показано ниже:

```c++
int class_name::shared_value;
```

Следующая программа SHARE_IT.CPP определяет класс book_series, совместно использующий элемент page_count, который является одинаковым для всех объектов (книг) класса (серии). Если программа изменяет значение этого элемента, изменение сразу же проявляется во всех объектах класса:

```c++
#include <iostream> 
#include <cstring>

class book_series {
 public:
  book_series(char *, char *, float);
  void show_book();
  void set_pages(int);

 private:
  static int page_count;
  char title[64];
  char author[64];
  float price;
};

int book_series::page__count;

void book_series::set_pages(int pages) {
  page_count = pages;
}

book_series::book_series(char *title, char *author, float price) {
  strcpy(book_series::title, title); 
  strcpy(book_series::author, author);
  book_series::price = price;
}

void book_series::show_book() {
  std::cout << "Заголовок: " << title << std::endl;
  std::cout << "Автор: " << author << std::endl;
  std::cout << "Цена: " << price << std::endl;
  std::cout << "Страницы: " << page_count << std::endl;
}

int main() {
  book_series programming(
    "Учимся программировать на C++", 
    "Jamsa", 
    22.95
  );

  book_series word(
    "Учимся работать с Word для Windows",
    "Wyatt",
    19.95
  );

  programming.show_book();
  word.show_book();

  std::cout << std::endl << "Изменение page_count " << std::endl;

  programming.set_pages(512);
  word.set_pages(256);
  
  programming.show_book();
  word.show_book();

  return 0;
}
```

Как видите, класс объявляет page_count как static int. Сразу же за определением класса программа объявляет элемент page_count как глобальную переменную. Когда программа изменяет элемент page_count, изменение сразу же проявляется во всех объектах класса book_series.

### Совместное использование элементов класса

В зависимости от вашей программы возможны ситуации, когда вам потребуется совместно использовать определенные данные несколькими экземплярами объекта. Для этого объявите такой элемент как static. Далее объявите этот элемент вне класса как глобальную переменную. Любые изменения, которые ваша программа делает с этим элементом, будут немедленно отражены в объектах данного класса.

### Использование элементов с атрибутами `public static`, если объекты не существуют

Как вы только что узнали, при объявлении элемента класса как static этот элемент совместно используется всеми объектами данного класса. Однако возможны ситуации, когда программа еще не создала объект, но ей необходимо использовать элемент. Для использования элемента ваша программа должна объявить его как public и static. Например, следующая программа USЕ_MBR.CPP использует элемент page_count из класса book_series, даже если объекты этого класса не существуют:

```c++
#include <iostream> 
#include <cstring>

class book_series { 
 public:
  static int page_count;
 
 private:
  char title [64];
  char author[64];
  float price;
};

int book_series::page_count;

int main() {
  book_series::page_count = 256;

  std::cout << 
    "Текущее значение page_count равно " << 
    book_series::page_count << 
    std::endl;

  return 0;
}
```

В данном случае, поскольку класс определяет элемент класса page_count как public, программа может обратиться к этому элементу класса, даже если объекты класса book_series не существуют.

## ИСПОЛЬЗОВАНИЕ СТАТИЧЕСКИХ ФУНКЦИЙ-ЭЛЕМЕНТОВ

Предыдущая программа иллюстрировала использование статических элементов данных. Подобным образом C++ позволяет вам определить статические функции-элементы (методы). Если вы создаете статический метод, ваша программа может вызывать такой метод, даже если объекты не были созданы. Например, если класс содержит метод, который может быть использован для данных вне класса, вы могли бы сделать этот метод статическим. Ниже приведен класс menu, который использует esc-последовательность драйвера ANSI для очистки экрана дисплея. Если в вашей системе установлен драйвер ANSI.SYS, вы можете использовать метод clear_screen для очистки экрана. Поскольку этот метод объявлен как статический, программа может использовать его, даже если объекты типа menu не существуют. Следующая программа CLR_SCR.CPP использует метод clear_screen для очистки экрана дисплея:

```c++
#include <iostream.h>

class menu { 
 public:
  static void clear_screen(void); 
  // Здесь должны быть другие методы

 private:
  int number_of_menu_options;
};

void menu::clear_screen(void) {
  std::cout << '\033' << "[2J";
}

void main() {
  menu::clear_screen();
  return 0;
}
```

Так как программа объявляет элемент clear_screen как статический, она может использовать эту функцию для очистки экрана, даже если объекты типа menu не существуют. Функция clear_screen использует esc-последовательность ANSI Esc[2J для очистки экрана.

> ### Использование в ваших программах методов класса
> 
> По мере создания методов класса возможны ситуации, когда функция, созданная вами для использования классом, может быть полезна для операций вашей программы, которые не включают объекты класса. Например, в классе menu была определена функция clear_screen, которую вы, возможно, захотите использовать в программе. Если ваш класс содержит метод, который вы захотите использовать вне объекта класса, поставьте перед его прототипом ключевое слово `static` и объявите этот метод как `public`:
> 
> ```c++
>  public:
>   static void clear_screen(void);
> ```
> 
> Внутри вашей программы для вызова такой функции используйте оператор глобального разрешения, как показано ниже:
> 
> ```c++
> menu::clear_screen();
> ```

## ЧТО ВАМ НЕОБХОДИМО ЗНАТЬ

Из этого урока вы узнали, что, если предварять элемент данных класса ключевым словом `static`, все объекты данного класса могут совместно использовать этот элемент.

Когда элемент данных является общим, ваши программы могут обращаться к его значению, даже если объекты этого класса не существуют.

Подобно этому, если ваши программы предваряют общий метод класса ключевым словом `static`, они могут использовать эту функцию для операций, которые не включают объекты класса. 

Из урока 26 вы узнаете, как использовать наследование для построения объекта из одного или нескольких уже существующих объектов. Использование наследования для создания новых объектов может сэкономить огромные усилия, затрачиваемые на программирование.

До изучения урока 26 убедитесь, что освоили следующие основные концепции:

1. Когда вы объявляете элемент класса как `static`, то такой элемент может совместно использоваться всеми объектами данного класса.

2. После того как ваша программа объявляет элемент класса как `static`, она должна вне определения класса объявить глобальную переменную, соответствующую совместно используемому элементу класса.

3. Если вы объявляете элемент как `public` и `static`, ваша программа может использовать такой элемент, даже если объекты данного класса не существуют. Для обращения к этому элементу ваша программа должна использовать оператор глобального разрешения, например `class_name::member_name`.

4. Если вы объявляете общую статическую функцию-элемент, ваша программа может вызывать эту функцию, даже если объекты данного класса не существуют. Для вызова данной функции программа должна использовать оператор глобального разрешения, например `menu::clear_screen()`.