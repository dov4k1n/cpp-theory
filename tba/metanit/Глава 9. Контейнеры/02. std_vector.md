https://metanit.com/cpp/tutorial/7.2.php

# std::vector\<T>

- [std::vector\<T\>](#stdvectort)
  - [Создание вектора](#создание-вектора)
  - [Размер вектора](#размер-вектора)
  - [Обращение к элементам и их перебор](#обращение-к-элементам-и-их-перебор)
  - [Добавление элементов](#добавление-элементов)
  - [Удаление элементов](#удаление-элементов)
  - [Изменение элементов вектора](#изменение-элементов-вектора)
  - [Сравнение векторов](#сравнение-векторов)

`std::vector<T>` представляет контейнер, который содержит коллекцию объектов одного типа.

Для работы с векторами необходимо включить заголовок:

```c++
#include <vector>
```

## Создание вектора

```c++
#include <vector>

int main() {
  std::vector<int> v1;
  // пустой вектор

  std::vector<int> v2(v1);
  // вектор v2 - копия вектора v1

  std::vector<int> v3 = v1;
  // вектор v3 - копия вектора v1

  std::vector<int> v4(5);
  // вектор v4 состоит из 5 чисел, каждое число равно 0

  std::vector<int> v5(5, 2);
  // вектор v5 состоит из 5 чисел, каждое число равно 2

  std::vector<int> v6{1, 2, 4, 5};
  // вектор v6 состоит из чисел 1, 2, 4, 5

  std::vector<int> v7 = {1, 2, 3, 5};
  // вектор v7 состоит из чисел 1, 2, 3, 5

  return 0;
}
```

Важно понимать отличие в данном случае круглых скобок от фигурных:

```c++
std::vector<int> v1(5);
// вектор состоит из 5 чисел, каждое равно 0

std::vector<int> v2{5};
// вектор состоит из одного числа, которое равно 5

std::vector<int> v3(5, 2);
// вектор состоит из 5 чисел, каждое равно 2

std::vector<int> v4{5, 2};
// вектор состоит из двух чисел 5 и 2
```

При этом можно хранить в векторе элементы только одного типа, который указан в угловых скобках. Значения других типов в вектор сохранить нельзя, как например, в следующем случае:

```c++
std::vector<int> v{5, "hi"};
// error
```

## Размер вектора

> ```c++
> vector.size()
> vector.empty()
>
> vector.resize(n)
> vector.resize(n, value)
> ```

С помощью функции `size()` можно узнать размер вектора, а с помощью функции `empty()` проверить, путой ли вектор:

```c++
#include <iostream>
#include <vector>
  
int main() {
  std::vector<int> numbers{1, 2, 3};

  if (numbers.empty())
    std::cout << "Vector is empty" << std::endl;
  else
    std::cout << "Vector has size " << numbers.size() << std::endl;
  // Vector has size 3

  return 0;
}
```
С помощью функции `resize()` можно изменить размер вектора. Эта функция имеет две формы:

* `resize(n)`: оставляет в векторе n первых элементов. Если вектор содержит больше элементов, то его размер усекается до n элементов. Если размер вектора меньше n, то добавляются недостающие элементы и инициализируются значением по умолчанию

* `resize(n, value)`: также оставляет в векторе n первых элементов. Если размер вектора меньше n, то добавляются недостающие элементы со значением value

Применение функции:

```c++
std::vector<int> numbers { 1, 2, 3, 4, 5, 6 };

numbers.resize(4);
// оставляем первые четыре элемента 
// {1, 2, 3, 4}
 
numbers.resize(6, 8);
// {1, 2, 3, 4, 8, 8}
```

**Важно учитывать, что применение функции `resize()` может сделать некорректными все итераторы, указатели и ссылки на элементы.**

## Обращение к элементам и их перебор

> ```c++
> vector[index]
> 
> vector.at(index)
> 
> vector.front()
> 
> vector.back()
> 
> for (auto n : vector)
> ```

Для обращения к элементам вектора можно использовать разные способы:

* `[index]`: получение элемента по индексу (также как и в массивах), индексация начинается с нуля

* `at(index)`: функция возращает элемент по индексу

* `front()`: возвращает первый элемент

* `back()`: возвращает последний элемент

Выполним перебор вектора и получим некоторые его элементы:

```c++
#include <iostream>
#include <vector>
  
int main() {
  std::vector<int> numbers {1, 2, 3, 4, 5};
   
  int first = numbers.front();
  // 1
  int last = numbers.back();
  // 5
  int second = numbers[1];
  // 2
  
  std::cout << "first: " << first << std::endl;
  std::cout << "second: " << second << std::endl;
  std::cout << "last: " << last << std::endl;
 
  numbers[0] = 6; 
  // изменяем значение   
  
  for(int n : numbers)
  std::cout << n << "\t";
  std::cout << std::endl;
  // 6  2  3  4  5

  return 0;
}
```

При этом следует учитывать, что индексация не добавляет элементов. Например, если вектор содержит 5 элементов, то мы не можем обратиться к шестому элементу:

```c++
std::vector<int> numbers {1, 2, 3, 4, 5};

numbers[5] = 9;
```
При таком обращении результат неопределен. Некоторые комиляторы могут генерировать ошибку, некоторые продолжат работать, но даже в этом случае такое обращение будет ошибочно, и оно в любом случае не добавит в вектор шестой элемент.

Чтобы избежать подобных ситуаций, можно использовать функцию `at()`, которая хотя также возвращает элемент по индексу, но при попытке обращения по недопустимому индексу будет генерировать исключение `out_of_range`:

```c++
#include <iostream>
#include <vector>
#include <stdexcept>
 
int main() {
  std::vector<int> numbers { 1, 2, 3, 4, 5};

  try {
  int n = numbers.at(8);
  }
  catch (std::out_of_range e) {
  std::cout << "Incorrect index" << std::endl;
  }

  return 0;
}
```

## Добавление элементов

> ```c++
> vector.push_back()
> vector.emplace_back()
>
> vector.emplace()
> vector.insert()
> ```

Для добавления элементов в вектор применяется функция `push_back()`, в которую передается добавляемый элемент:

```c++
#include <iostream>
#include <vector>
  
int main() {
  std::vector<int> numbers;
  
  numbers.push_back(5);
  numbers.push_back(3);
  numbers.push_back(10);
  
  for(int n : numbers)
    std::cout << n << "\t";
  std::cout << std::endl;
  // 5  3  10

  return 0;
}
```

Векторы являются динамическими структурами в отличие от массивов, где мы скованы его заданым размером. Поэтому мы можем динамически добавлять в вектор новые данные.

Функция `emplace_back()` выполняет аналогичную задачу - добавляет элемент в конец контейнера:

```c++
std::vector<int> numbers{ 1, 2, 3, 4, 5 };

numbers.emplace_back(8);
// { 1, 2, 3, 4, 5, 8 };
```

Ряд функций позволяет добавлять элементы на определенную позицию.

* `emplace(pos, value)`: вставляет элемент value на позицию, на которую указывает итератор pos

* `insert(pos, value)`: вставляет элемент value на позицию, на которую указывает итератор pos, аналогично функции emplace

* `insert(pos, n, value)`: вставляет n элементов value начиная с позиции, на которую указывает итератор pos

* `insert(pos, begin, end)`: вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из диапазона между итераторами begin и end

* `insert(pos, values)`: вставляет список значений начиная с позиции, на которую указывает итератор pos

Функция `emplace()`:

```c++
std::vector<int> numbers{ 1, 2, 3, 4, 5 };

auto iter = numbers.cbegin();
// константный итератор указывает на первый элемент

numbers.emplace(iter + 2, 8);
// добавляем после второго элемента
// numbers = { 1, 2, 8, 3, 4, 5}
```

Функция `insert()`:

```c++
std::vector<int> numbers1{ 1, 2, 3, 4, 5 };

auto iter1 = numbers1.cbegin();
// константный итератор указывает на первый элемент

numbers1.insert(iter1 + 2, 8);
// добавляем после второго элемента  
// numbers1 = { 1, 2, 8, 3, 4, 5};



std::vector<int> numbers2 { 1, 2, 3, 4, 5 };

auto iter2 = numbers2.cbegin();
// константный итератор указывает на первый элемент

numbers2.insert(iter2 + 1, 3, 4);
// добавляем после первого элемента три четверки  
// numbers2 = { 1, 4, 4, 4, 2, 3, 4, 5};



std::vector<int> values { 10, 20, 30, 40, 50 };

std::vector<int> numbers3 { 1, 2, 3, 4, 5 };

auto iter3 = numbers3.cbegin();
// константный итератор указывает на первый элемент

numbers3.insert(iter3 + 1, values.begin(), values.begin() + 3);
// добавляем после первого элемента три первых элемента из вектора values
// numbers3 = { 1, 10, 20, 30, 2, 3, 4, 5};



std::vector<int> numbers4 { 1, 2, 3, 4, 5 };

auto iter4 = numbers4.cend();
// константный итератор указывает на позицию за последним элементом

numbers4.insert(iter4, { 21, 22, 23 });
// добавляем в конец вектора numbers4 элементы из списка { 21, 22, 23 }
// numbers4 = { 1, 2, 3, 4, 5, 21, 22, 23};
```

## Удаление элементов

> ```c++
> vector.clear()
> vector.pop_back()
>
> vector.erase(p)
> vector.erase(begin, end)
>
>std::erase(vector, value)
> ```

Если необходимо удалить все элементы вектора, то можно использовать функцию `clear()`:

```c++
std::vector<int> v { 1, 2, 3, 4 };

v.clear();
// v = {}
```

Функция `pop_back()` удаляет последний элемент вектора:

```c++
std::vector<int> v { 1, 2, 3, 4 };

v.pop_back();
// v = { 1, 2, 3 }
```

Если нужно удалить элемент из середины или начала контейнера, применяется метод `erase()`, который имеет следующие формы:

* `erase(p)`: удаляет элемент, на который указывает итератор `p`. Возвращает итератор на элемент, следующий после удаленного, или на конец контейнера, если удален последний элемент

* `erase(begin, end)`: удаляет элементы из диапазона, на начало и конец которого указывают итераторы `begin` и `end`. Возвращает итератор на элемент, следующий после последнего удаленного, или на конец контейнера, если удален последний элемент

Применение функции `erase()`:

```c++
std::vector<int> numbers1 { 1, 2, 3, 4, 5, 6 };

auto iter = numbers1.cbegin();
// указатель на первый элемент

numbers1.erase(iter + 2);
// удаляем третий элемент
// numbers1 = { 1, 2, 4, 5, 6 }



std::vector<int> numbers2 = { 1, 2, 3, 4, 5, 6 };

auto begin = numbers2.cbegin();
// указатель на первый элемент

auto end = numbers2.cend();
// указатель на последний элемент

numbers2.erase(begin + 2, end - 1);
// удаляем с третьего элемента до последнего
// numbers2 = {1, 2, 6}
```

Также начиная со стандарта `c++20` в язык была добавлена функция `std::erase()`. Она не является частью `vector`. В качестве первого параметра она принимает вектор, а в качестве второго - элемент, который надо удалить:

```c++
std::vector<int> numbers3 { 1, 2, 3, 1, 5, 6 };

std::erase(numbers3, 1);
// numbers3 = { 2, 3, 4, 5, 6 }
```

В данном случае удаляем из вектора `numbers3` все вхождения числа `1`.

## Изменение элементов вектора

> ```c++
> vector.assign(il)
> vector.assign(n, value)
> 
> vector.swap(other_vector)
> ```

Функция `assign()` позволяет заменить все элементы вектора определенным набором:

```c++
std::vector<std::string> langs = { "Java", "JavaScript", "C" };

langs.assign(4, "C++");
// {"C++", "C++", "C++", "C++"}
```

В данном случае элементы вектора заменяются набором из четырех строк "C++".

Также можно передать непосредственно набор значений, который заменит значения вектора:

```c++
std::vector<std::string> langs { "Java", "JavaScript", "C"};

langs.assign({ "C++", "C#", "C"});
// { "C++", "C#", "C"}
```

Еще одна функция - `swap()` обменивает значения двух контейнеров:

```c++
std::vector<std::string> clangs { "C++", "C#", "Java" };

std::vector<std::string> ilangs { "JavaScript", "Python", "PHP"};

clangs.swap(ilangs);
// clangs = { "JavaScript", "Python", "PHP"}
```

## Сравнение векторов

Векторы можно сравнивать - они поддерживают все операции сравнения: <, >, <=, >=, ==, !=

Сравнение контейнеров осуществляется на основании сравнения пар элементов на тех же позициях.

Векторы равны, если они содержат одинаковые элементы на тех же позициях. Иначе они не равны:

```c++
std::vector<int> v1 {1, 2, 3};

std::vector<int> v2 {1, 2, 3};

std::vector<int> v3 {3, 2, 1};
   
bool is_v1_v2_equal = v1 == v2;
// true

bool is_v1_v3_not_equal = v1 != v3;
// true

bool is_v2_v3_equal = v2 == v3;
// false
```