https://metanit.com/cpp/tutorial/7.6.php

# std::list\<T>

- [std::list\<T\>](#stdlistt)
  - [Создание списка](#создание-списка)
  - [Получение элементов](#получение-элементов)
  - [Размер списка](#размер-списка)
  - [Изменение элементов списка](#изменение-элементов-списка)
  - [Добавление элементов](#добавление-элементов)
  - [Удаление элементов](#удаление-элементов)

Контейнер `std::list<T>` представляет двухсвязный список.

То есть такой список, где каждый элемент имеет указатели на предыдущий и последовательный элемент. Благодаря чему мы можем перемещаться по списку как вперед, так и назад. 

Для использования списка необходимо подключить заголовочный файл 
```c++
#include <list>
```

## Создание списка

```c++
#include <list>

int main() { 
  std::list<int> list1;
  // пустой список

  std::list<int> list2(5);
  // список list2 состоит из 5 чисел, 
  // каждый элемент имеет значение по умолчанию
  
  std::list<int> list3(5, 2);
  // список list3 состоит из 5 чисел, 
  // каждое число равно 2

  std::list<int> list4{ 1, 2, 4, 5 };
  // список list4 состоит из чисел 1, 2, 4, 5

  std::list<int> list5 = { 1, 2, 3, 5 };
  // список list5 состоит из чисел 1, 2, 4, 5

  std::list<int> list6(list4);
  // список list6 - копия списка list4

  std::list<int> list7 = list4;
  // список list7 - копия списка list4 

  return 0;
}
```

## Получение элементов

> ```c++
> list.front()
> list.back()
> 
> for (auto n : list)
> 
> iter = list.begin()
> iter = list.end()
> ```

В отличие от других контейнеров для типа list не определена операция обращения по индексу или функция `at()`, которая выполняет похожую задачу.

Тем не менее для контейнера list можно использовать функции `front()` и `back()`, которые возвращают соответственно первый и последний элементы.

Чтобы обратиться к элементам, которые находятся в середине (после первого и до последнего элементов), придется выполнять перебор элементов с помощью циклов или итераторов:

```c++
#include <iostream>
#include <list>
 
int main() {
  std::list<int> numbers{ 1, 2, 3, 4, 5 };
  
  int first {numbers.front() };
  // 1
  int last { numbers.back() };
  // 5
 
  std::cout << "First: " << first << std::endl;
  std::cout << "Last: " << last << std::endl;
  
  // перебор в цикле
  for (int n : numbers)
    std::cout << n << "\t";
  std::cout << std::endl;
  
  // перебор с помощью итераторов
  for (auto iter = numbers.begin(); iter != numbers.end(); iter++) {
    std::cout << *iter << "\t";
  }
  std::cout << std::endl;

  return 0;
}
```

## Размер списка

> ```c++
> list.size()
>
> list.empty()
> 
> list.resize(n)
> list.resize(n, value)
> ```

Для получения размера списка можно использовать функцию `size()`:

```c++
std::list<int> numbers{ 1, 2, 3, 4, 5 };

int size = numbers.size();
// 5
```

Функция `empty()` позволяет узнать, пуст ли список. Если он пуст, то функция возвращает значение `true`, иначе возвращается значение `false`:

```c++
std::list<int> numbers{ 1, 2, 3, 4, 5 };

if (numbers.empty())
  std::cout << "The list is empty" << std::endl;
else
  std::cout << "The list is not empty" << std::endl;
```

С помощью функции `resize()` можно изменить размер списка. Эта функция имеет две формы:

* `resize(n)`: оставляет в списке n первых элементов. Если список содержит больше элементов, то он усекается до первых n элементов. Если размер списка меньше n, то добавляются недостающие элементы и инициализируются значением по умолчанию

* `resize(n, value)`: также оставляет в списке n первых элементов. Если размер списка меньше n, то добавляются недостающие элементы со значением value

Применение функции:

```c++
std::list<int> numbers{ 1, 2, 3, 4, 5, 6 };

numbers.resize(4);
// оставляем первые четыре элемента
// numbers = {1, 2, 3, 4}
 
numbers.resize(6, 8);
// numbers = {1, 2, 3, 4, 8, 8}
```

## Изменение элементов списка

> ```c++
> list.assign(il)
>
> list.assign(n, value)
> 
> list.assign(begin, end)
> 
> list.swap(other_list)
> ```

Функция `assign()` позволяет заменить все элементы списка определенным набором. Она имеет следующие формы:

* `assign(il)`: заменяет содержимое контейнера элементами из списка инициализации il

* `assign(n, value)`: заменяет содержимое контейнера n элементами, которые имеют значение value

* `assign(begin, end)`: заменяет содержимое контейнера элементами из диапазона, на начало и конец которого указывают итераторы `begin` и `end`

Применение функции:

```c++
std::list<int> numbers { 1, 2, 3, 4, 5 };

numbers.assign({ 21, 22, 23, 24, 25 });
// numbers = { 21, 22, 23, 24, 25 }

numbers.assign(4, 3);
// numbers = {3, 3, 3, 3}


std::list<int> values { 6, 7, 8, 9, 10, 11 };

auto start = ++values.begin();
// итератор указывает на второй элемент из values

auto end = values.end();

numbers.assign(start, end);
// numbers = { 7, 8, 9, 10, 11 }
```

Функция `swap()` обменивает значениями два списка:

```c++
std::list<int> list1{ 1, 2, 3, 4, 5 };

std::list<int> list2{ 6, 7, 8, 9};

list1.swap(list2);
// list1 = { 6, 7, 8, 9};
// list2 = { 1, 2, 3, 4, 5 };
```

## Добавление элементов

Для добавления элементов в контейнер list применяется ряд функций.

* `push_back(val)`: добавляет значение val в конец списка

* `push_front(val)`: добавляет значение val в начало списка

* `emplace_back(val)`: добавляет значение val в конец списка

* `emplace_front(val)`: добавляет значение val в начало списка

* `emplace(pos, val)`: вставляет элемент val на позицию, на которую указывает итератор pos. Возвращает итератор на добавленный элемент

* `insert(pos, val)`: вставляет элемент val на позицию, на которую указывает итератор pos, аналогично функции emplace. Возвращает итератор на добавленный элемент

* `insert(pos, n, val)`: вставляет n элементов val начиная с позиции, на которую указывает итератор pos. Возвращает итератор на первый добавленный элемент. Если n = 0, то возвращается итератор pos.

* `insert(pos, begin, end)`: вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из диапазона между итераторами begin и end. Возвращает итератор на первый добавленный элемент. Если между итераторами begin и end нет элементов, то возвращается итератор pos.

* `insert(pos, values)`: вставляет список значений values начиная с позиции, на которую указывает итератор pos. Возвращает итератор на первый добавленный элемент. Если values не содержит элементов, то возвращается итератор pos.

Пример работы функций `push_back()`, `push_front()`, `emplace_back()` и `emplace_front()`:

```c++
std::list<int> numbers{ 1, 2, 3, 4, 5 };

numbers.push_back(23);
// { 1, 2, 3, 4, 5, 23 }

numbers.push_front(15);
// { 15, 1, 2, 3, 4, 5, 23 }

numbers.emplace_back(24);
// { 15, 1, 2, 3, 4, 5, 23, 24 }

numbers.emplace_front(14);
// { 14, 15, 1, 2, 3, 4, 5, 23, 24 }
```

Добавление в середину списка с помощью функции `emplace()`:

```c++
std::list<int> numbers{ 1, 2, 3, 4, 5 };

auto iter = ++numbers.cbegin();
// итератор указывает на второй элемент

numbers.emplace(iter, 8);
// добавляем после первого элемента
// numbers = { 1, 8, 2, 3, 4, 5};
```

Добавление в середину списка с помощью функции `insert()`:

```c++
std::list<int> numbers1{ 1, 2, 3, 4, 5 };

auto iter1 = numbers1.cbegin(); 
// итератор указывает на первый элемент

numbers1.insert(iter1, 0); 
// добавляем начало списка  
// numbers1 = { 0, 1, 2, 3, 4, 5};



std::list<int> numbers2{ 1, 2, 3, 4, 5 };

auto iter2 = numbers2.cbegin(); 
// итератор указывает на первый элемент

numbers2.insert(++iter2, 3, 4); 
// добавляем после первого элемента три четверки  
// numbers2 = { 1, 4, 4, 4, 2, 3, 4, 5};



std::list<int> values { 10, 20, 30, 40, 50 };

std::list<int> numbers3{ 1, 2, 3, 4, 5 };

auto iter3 = numbers3.cbegin(); 
// итератор указывает на первый элемент

numbers3.insert(iter3, values.begin(), values.end());
// добавляем в начало все элементы из values
// numbers3 = { 10, 20, 30, 40, 50, 1, 2, 3, 4, 5};



std::list<int> numbers4{ 1, 2, 3, 4, 5 };

auto iter4 = numbers4.cend();
// итератор указывает на позицию за последним элементом

numbers4.insert(iter4, { 21, 22, 23 });
// добавляем в конец список из трех элементов
// numbers4 = { 1, 2, 3, 4, 5, 21, 22, 23};
```

## Удаление элементов

Для удаления элементов из контейнера `list` могут применяться следующие функции:

* `clear()`: удаляет все элементы

* `pop_back()`: удаляет последний элемент

* `pop_front()`: удаляет первый элемент

* `erase(p)`: удаляет элемент, на который указывает итератор p. Возвращает итератор на элемент, следующий после удаленного, или на конец контейнера, если удален последний элемент

* `erase(begin, end)`: удаляет элементы из диапазона, на начало и конец которого указывают итераторы begin и end. Возвращает итератор на элемент, следующий после последнего удаленного, или на конец контейнера, если удален последний элемент

Применение функций:

```c++
std::list<int> numbers { 1, 2, 3, 4, 5 };

numbers.pop_front();
// numbers = { 2, 3, 4, 5 }

numbers.pop_back();
// numbers = { 2, 3, 4 }

numbers.clear();
// numbers = {}



numbers = { 1, 2, 3, 4, 5 };

auto iter = numbers.cbegin();
// указатель на первый элемент

numbers.erase(iter);
// удаляем первый элемент
// numbers = { 2, 3, 4, 5 }



numbers = { 1, 2, 3, 4, 5 };

auto begin = numbers.begin();
// указатель на первый элемент

auto end = numbers.end();
// указатель на последний элемент

numbers.erase(++begin, --end);
// удаляем со второго элемента до последнего
//numbers = {1, 5}
```