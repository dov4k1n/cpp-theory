https://phys.bspu.by/static/um/inf/prg/sem3/book/book_c/

# Частные элементы и друзья

- [Частные элементы и друзья](#частные-элементы-и-друзья)
  - [ОПРЕДЕЛЕНИЕ ДРУЗЕЙ КЛАССА](#определение-друзей-класса)
  - [ОГРАНИЧЕНИЕ КОЛИЧЕСТВА ДРУЗЕЙ](#ограничение-количества-друзей)
  - [ЧТО ВАМ НЕОБХОДИМО ЗНАТЬ](#что-вам-необходимо-знать)

Как вы уже знаете, ваши программы могут обращаться к частным (private) элементам класса только с помощью функций-элементов этого же класса. Используя частные элементы класса вместо общих во всех ситуациях, где это только возможно, вы уменьшаете возможность программы испортить значения элементов класса, так как программа может обращаться к таким элементам только через интерфейсные функции (которые управляют доступом к частным элементам). Однако в зависимости от использования объектов вашей программы, иногда вы можете существенно увеличить производительность позволяя одному классу напрямую обращаться к частным элементам другого. В этом случае уменьшаются издержки (требуемое время выполнения) на вызов интерфейсных функций. В подобных ситуациях C++ позволяет определить класс в качестве друга (friend} другого класса и разрешает классу-другу доступ к частным элементам этого другого класса. В этом уроке объясняется, как ваши программы могут указать, что два класса являются друзьями. К концу данного урока вы освоите следующие основные концепции:

* Используя ключевое слово friend, класс может сообщить C++, кто является его другом, т. е. другими словами, что другие классы могут обращаться напрямую к его частным элементам.
* 
* Частные элементы класса защищают данные класса, следовательно, вы должны ограничить круг классов-друзей только теми классами, которым действительно необходим прямой доступ к частным элементам искомого класса.

* C++ позволяет ограничить дружественный доступ определенным набором функций.

Частные (private) элементы позволяют вам защищать классы и уменьшить вероятность ошибок. Таким образом, вы должны ограничить использование классов-друзей настолько, насколько это возможно. Иногда программа напрямую может изменить значения элементов класса, это увеличивает вероятность появления ошибок.

## ОПРЕДЕЛЕНИЕ ДРУЗЕЙ КЛАССА

C++ позволяет друзьям определенного класса обращаться к частным элементам этого класса. Чтобы указать C++, что один класс является другом (friend) другого класса, вы просто помещаете ключевое слово friend и имя соответствующего класса-друга внутрь определения этого другого класса. Например, приведенный ниже класс book объявляет класс librarian своим другом. Поэтому объекты класса librarian могут напрямую обращаться к частным элементам класса book, используя оператор точку:

```c++
class book {
 public:
  book (char *, char *, char *);
  void show_book();
  friend librarian;

 private:
  char title[64];
  char author[64];
  char catalog[64];
};
```

Как видите, чтобы указать друга, необходим только один оператор внутри определения класса. Например, следующая программа VIEWBOOK.CPP использует librarian в качестве друга класса book. Следовательно, функции класса librarian могут напрямую обращаться к частным элементам класса book. В данном случае программа использует функцию change_catalog класса librarian для изменения номера карточки каталога определенной книги:

```c++
#include <iostream.h>
#include <string.h>

class book {
 public:
  book(char *, char *, char *);
  void show_book();
  friend librarian;

 private:
  char title[64];
  char author[64];
  char catalog[64];
};

book::book(char *title, char *author, char •catalog) {
  strcpy(book::title, title);
  strcpy(book::author, author);
  strcpy(book::catalog, catalog);
}

void book::show_book() {
  std::cout << "Название: " << title << std::endl;
  std::cout << "Автор: " << author << std::endl;
  std::cout << "Каталог: " << catalog << std::endl;
}

class librarian {
 public:
  void change_catalog(book *, char *);
  char *get_catalog(book);
};

void librarian::change_catalog(
  book *this_book, 
  char *new_catalog
) {
  strcpy(this_book->catalog, new_catalog);
}

char *librarian::get__catalog(book this_book) {
  static char catalog[64];
  strcpy(catalog, this_book.catalog);
  return(catalog) ;
}

void main() {
  book programming(
    "Учимся программировать на языке C++", 
    "Jamsa", 
    "P101"
  );

  librarian library;
  
  programming.show_book();
  
  library.change_catalog(&programming, "Легкий C++ 101");
  
  programming.show_book();

  return 0;
}
```

Как видите, программа передает объект book в функцию change_catalog класса librarian по адресу. Поскольку эта функция изменяет элемент класса book, программа должна передать параметр по адресу, а затем использовать указатель для обращения к элементу этого класса. Экспериментируйте с данной программой, попробуйте удалить оператор friend из определения класса book. Поскольку класс librarian больше не имеет доступа к частным элементам класса book, компилятор C++ сообщает о синтаксических ошибках при каждой ссылке на частные данные класса book.

> ### О друзьях класса
> 
> Обычно единственный способ, с помощью которого ваши программы могут обращаться к частным элементам класса, заключается в использовании интерфейсных функций. В зависимости от использования объектов программы иногда может быть удобным (или более эффективным с точки зрения скорости вычислений) разрешить одному классу обращаться к частным элементам другого. Для этого вы должны информировать компилятор C++, что класс является другом (friend). Компилятор, в свою очередь, позволит классу-другу обращаться к частным элементам требуемого класса. Чтобы объявить класс другом, поместите ключевое слово friend и имя класса-друга в секцию public определения класса, как показано ниже:
> 
> ```c++
> class abbott {
>  public:
>   friend costello;
>   // Общие элементы 
>  private:
>   // Частные элементы 
> };
> ```

> ### Как друзья отличаются от защищенных (protected) элементов
> 
> Из урока 26 вы узнали, что в C++ существуют защищенные (protected) элементы класса, что позволяет производным классам обращаться к защищенным элементам базового класса напрямую, используя оператор точку. Помните, что к защищенным элементам класса могут обращаться только те классы, которые являются производными от данного базового класса, другими словами, классы, которые наследуют элементы базового класса (защищенные элементы класса являются как бы частными по отношению к остальным частям программы). Классы-друзья C++ обычно не связаны между собой узами наследования. Единственный способ для таких не связанных между собой классов получить доступ к частным элементам другого класса состоит в том, чтобы этот другой класс информировал компилятор, что данный класс является другом.


## ОГРАНИЧЕНИЕ КОЛИЧЕСТВА ДРУЗЕЙ

Как вы только что узнали, если вы объявляете один класс другом другого класса, вы обеспечиваете классу-другу доступ к частным элементам данных этого другого класса. Вы также знаете и то, что чем больше доступа к частным данным класса, тем больше шансов на внесение ошибок в программу. Следовательно, если доступ к частным данным другого класса необходим только нескольким функциям класса, C++ позволяет указать, что только определенные функции дружественного класса будут иметь доступ к частным элементам. Предположим, например, что класс librarian, представленный в предыдущей программе, содержит много разных функций. Однако предположим, что только функциям change_catalog и get_catalog необходим доступ к частным элементам класса book. Внутри определения класса book мы можем ограничить доступ к частным элементам только этими двумя функциями, как показано ниже:

```c++
class book {
 public:
  book(char *, char *, char *);
  void show_book();
  friend char *librarian::get_catalog(book);
  friend void librarian: :change_catalog(book *, char *);

 private:
  char title[64];
  char author[64];
  char catalog[64];
};
```

Как видите, операторы friend содержат полные прототипы всех дружественных функций, которые могут напрямую обращаться к частным элементам.

> ### О функциях-друзьях
>
> Если ваша программа использует друзей для доступа к частным данным класса, вы можете ограничить количество функций-элементов класса-друга, который может обращаться к частным данным, используя дружественные функции. Для объявления функции-друга укажите ключевое слово friend, за которым следует полный прототип, как показано ниже:
>
> ```c++
>  public:
>   friend class_name::function_name(parameter types);
> ```
>
> Только функции-элементы, указанные как друзья, могут напрямую обращаться к частным элементам класса, используя оператор точку.

Если ваша программа начинает ссылаться на один класс из другого, вы можете получить синтаксические ошибки, если порядок определения классов неверен. В данном случае определение класса book использует прототипы функций, определенные в классе librarian. Следовательно, определение класса librarian должно предшествовать определению класса book. Однако если вы проанализируете класс librarian, то обнаружите, что он ссылается на класс book:

```c++
class librarian {
 public:
  void change_catalog(book *, char *);
  char *get_catalog(book);
};
```

Поскольку вы не можете поставить определение класса book перед определением класса librarian, C++ позволяет вам объявить класс book, тем самым сообщая компилятору, что такой класс есть, а позже определить его. Ниже показано, как это сделать:

```c++
class book; // объявление класса
```

Следующая программа LIMITFRI.CPP использует дружественные функции для ограничения доступа класса librarian к частным данным класса book. Обратите внимание на порядок определения классов:

```c++
#include <iostream.h> 
#include <string.h>

class book;

class librarian {
 public:
  void change_catalog(book *, char *);
  char *get_catalog(book);
};

class book {
 public:
  book(char *, char *, char *);
  void show_book();
  friend char *librarian::get_catalog(book);
  friend void librarian::change_catalog(book *, char *);

 private:
  char title[64];
  char author[64];
  char catalog[64];
};

book::book(char *title, char *author, char *catalog) {
  strcpy(book::title, title);
  strcpy(book::author, author);
  strcpy(book::catalog, catalog);
}

void book::show_book() {
  std::cout << "Название: " << title << std::endl;
  std::cout << "Автор: " << author << std::endl;
  std::cout << "Каталог: " << catalog << std::endl;
}

void librarian::change_catalog(book *this_book, char *new_catalog) {
  strcpy(this_book->catalog, new_catalog);
}

char *librarian::get_catalog(book this_book){
  static char catalog[64];
  strcpy(catalog, this_book.catalog);
  return(catalog);
}

void main() {
  book programming(
    "Учимся программировать на C++", 
    "Jamsa", 
    "P101"
  );

  librarian library;

  programming.show_book();

  library.change_catalog(&programming, "Легкий C++ 101");

  programming.show_book();

  return 0;
}
```

Как видите, программа сначала использует объявление, чтобы сообщить компилятору, что класс book будет определен позже. Поскольку объявление извещает компилятор о классе book, определение класса librarian может ссылаться на класс book, который еще не определен в программе.

> ### Что такое идентификатор класса
> 
> Идентификатор представляет собой имя, например имя переменной или класса. Если ваши программы используют дружественные классы, то может случиться, что определение одного класса ссылается на другой класс (его имя или идентификатор), о котором компилятор C++ еще ничего не знает. В таких случаях компилятор C++ будет сообщать о синтаксических ошибках. Чтобы избавиться от ошибок типа "что следует определять сначала", C++ позволяет вам включать в начало исходного текста программы объявление класса, тем самым вводя идентификатор класса:
> 
> ```c++
> class class_name;
> ```
> Эта строка сообщает компилятору, что ваша программа позже определит указанный класс, а пока программе разрешается ссылаться на этот класс.

## ЧТО ВАМ НЕОБХОДИМО ЗНАТЬ

В данном уроке вы изучили, как использовать классы-друзья для обращения к частным элементам другого класса напрямую с использованием оператора точки.

В уроке 29 вы изучите, как использовать в C++ шаблоны функций для упрощения определения подобных функций. 

Но прежде чем перейти к уроку 29 убедитесь, что вы освоили следующее:

1. Использование в ваших программах на C++ друзей позволяет одному классу обращаться к частным элементам другого класса напрямую, используя оператор точку.

2. Для объявления одного класса другом (friend) другого класса вы должны внутри определения этого другого класса указать ключевое слово friend, за которым следует имя первого класса.

3. После объявления класса другом по отношению к другому классу, все функции-элементы класса-друга могут обращаться к частным элементам этого другого класса.

4. Чтобы ограничить количество дружественных методов, которые могут обращаться к частным данным класса, C++ позволяет указать дружественные функции. Для объявления функции-друга вы должны указать ключевое слово friend, за которым следует прототип функции, которой, собственно, и необходимо обращаться к частным элементам класса.

5. При объявлении дружественных функций вы можете получить синтаксические ошибки, если неверен порядок определений классов. Если необходимо сообщить компилятору, что идентификатор представляет имя класса, который программа определит позже, вы можете использовать оператор такого вида class class_name;.