https://phys.bspu.by/static/um/inf/prg/sem3/book/book_c/

# Перегрузка операторов

- [Перегрузка операторов](#перегрузка-операторов)
  - [ПЕРЕГРУЗКА ОПЕРАТОРОВ ПЛЮС И МИНУС](#перегрузка-операторов-плюс-и-минус)
    - [Второй пример](#второй-пример)
  - [ОПЕРАТОРЫ, КОТОРЫЕ Вbl HE МОЖЕТЕ ПЕРЕГРУЗИТЬ](#операторы-которые-вbl-he-можете-перегрузить)
  - [ЧТО ВАМ НЕОБХОДИМО ЗНАТЬ](#что-вам-необходимо-знать)

Как вы уже знаете, тип переменной определяет набор значений, которые она может хранить, а также набор операций, которые можно выполнять над этой переменной. Например, над значением переменной типа int ваша программа может выполнять сложение, вычитание, умножение и деление. С другой стороны, использование оператора плюс для сложения двух строк лишено всякого смысла. Когда вы определяете в своей программе класс, то по существу вы определяете новый тип. А если так, C++ позволяет вам определить операции, соответствующие этому новому типу.

Перегрузка оператора состоит в изменении смысла оператора (например, оператора плюс (+), который обычно в C++ используется для сложения) при использовании его с определенным классом. В данном уроке вы определите класс string и перегрузите операторы плюс и минус. Для объектов типа string оператор плюс будет добавлять указанные символы к текущему содержимому строки. Подобным образом оператор минус будет удалять каждое вхождение указанного символа из строки. К концу данного урока вы изучите следующие основные концепции:

* Вы перегружаете операторы для улучшения удобочитаемости ваших программ, но перегружать операторы следует только в том случае, если это упрощает понимание вашей программы. 

* Для перегрузки операторов программы используют ключевое слово C++ operator. 

* Переопределяя оператор, вы указываете функцию, которую C++ вызывает каждый раз, когда класс использует перегруженный оператор. Эта функция, в свою очередь, выполняет соответствующую операцию. 

* Если ваша программа перегружает оператор для определенного класса, то смысл этого оператора изменяется только для указанного класса, оставшаяся часть программы будет продолжать использовать этот оператор для выполнения его стандартных операций. 

* C++ позволяет перегружать большинство операторов, за исключением четырех, перечисленных в таблице 24, которые программы не могут перегружать. 

Перегрузка операторов может упростить наиболее общие операции класса и улучшить читаемость программы. Найдите время для эксперимента с программами, представленными в этом уроке, и вы обнаружите, что перегрузка операторов выполняется очень просто.

## ПЕРЕГРУЗКА ОПЕРАТОРОВ ПЛЮС И МИНУС

Когда вы перегружаете оператор для какого-либо класса, то смысл данного оператора не изменяется для переменных других типов. Например, если вы перегружаете оператор плюс для класса string, то смысл этого оператора не изменяется, если необходимо сложить два числа. Когда компилятор С++ встречает в программе оператор, то на основании типа переменной он определяет ту операцию, которая должна быть выполнена.

Ниже приведено определение класса, создающее класс string. Этот класс содержит один элемент данных, который представляет собой собственно символьную строку. Кроме того, этот класс содержит несколько различных методов и пока не определяет каких-либо операторов:

```c++
class string { 
  public:
  string(char *); // Конструктор 
  void str_append(char *);
  void chr_minus(char);
  void show_string(void);

  private:
  char data[256];
};
```

Как видите, класс определяет функцию str_append, которая добавляет указанные символы к содержимому строки класса. Аналогичным образом функция chr_minus - удаляет каждое вхождение указанного символа из строки класса. Следующая программа STRCLASS.CPP использует класс string для создания двух объектов символьных строк и манипулирования ими.

```c++
#include <iostream.h> 
#include <string.h>

class string {
  public:
  string(char *); // Конструктор 
  void str_append(char *);
  void chr_minus(char);
  void show_string(void);

  private:
  char data[256];
};

string::string(char *str) {
  strcpy(data, str);
}

void string::str_append(char *str) {
  strcat(data, str);
}

void string::chr_minus(char letter) {
  char temp[256];
  int i, j;

  for (i = 0, j = 0; data[i]; i++)
    // Эту букву необходимо удалить?
    if (data[i] != letter)
      // Если нет, присвоить ее temp
      temp[j++] = data[i];
  
  temp[j] = NULL; // Конец temp

  // Копировать содержимое temp обратно в data 
  strcpy(data, temp);
}

void string::show_string(void) {
  cout << data << endl;
}

int main() {
  string title( "Учимся программировать на языке C++");
  string lesson("Перегрузка операторов");

  title.show_string();
  title.str_append(" я учусь!");
  title.show_string();

  lesson.show_string();
  lesson.chr_minus('p');
  lesson.show_string();

  return 0;
}
```

Как видите, программа использует функцию str_append для добавления символов к строковой переменной title. Программа также использует функцию chr_minus для удаления каждой буквы "р" из символьной строки lesson. В данном случае программа использует вызовы функции для выполнения этих операций. Однако, используя перегрузку операторов, программа может выполнять идентичные операции с помощью операторов плюс (+) и минус (-).

При перегрузке оператора используйте ключевое слово C++ operator вместе с прототипом и определением функции, чтобы сообщить компилятору C++, что класс будет использовать этот метод как оператор. Например, следующее определение класса использует ключевое слово operator, чтобы назначить операторы плюс и минус функциям str_append и chr_minus внутри класса string:

```c++
class string {
  public:
  string(char *); // Конструктор 
  void operator +(char *);
  void operator -(char); // Определение операторов класса
  void show_string(void);

  private:
  char data[256];
};
```

Как видите, класс перегружает операторы плюс и минус. Как уже упоминалось, когда класс перегружает оператор, он должен указать функцию, которая реализует операцию, соответствующую этому оператору. В случае оператора плюс определение такой функции становится следующим:

```c++
void string::operator +(char *str) {
  strcat(data, str);
}
```
Как видите, определение этой функции не содержит имени, поскольку здесь определяется перегруженный оператор класса. Для перегрузки оператора плюс программа не изменила обработку, которая осуществляется внутри функции (код этой функции идентичен коду предыдущей функции str_append). Вместо этого программа просто заменила имя функции ключевым словом operators соответствующим оператором. Следующая программа OPOVERLD.CPP иллюстрирует использование перегружаемых операторов плюс и минус:

```c++
#include <iostream.h> 
#include <string.h>
class string {
 public:
  string(char *); // Конструктор 
  void operator +(char *);
  void operator -(char);
  void show_string(void);

  private:
  char data[256];
};

string::string(char *str) {
  strcpy(data, str);
}

void string::operator +(char *str) {
  strcat(data, str);
}

void string::operator -(char letter) {
  char temp[256] ;
  int i, j;

  for (i = 0, j = 0; data[i]; i++)
    if (data[il 1= letter)
      temp[j++] = data[i];

  temp[j] = NULL;
  strcpy(data, temp);
}

void string::show_string(void) {
  cout << data << endl;
}

int main() {
  string title( "Учимся программировать на C++");
  string lesson("Перегрузка операторов");

  title.show_string();
  title + " я учусь!";
  title.show_string() ;

  lesson.show_string();
  lesson - 'P';
  lesson.show_string();

  return 0;
}
```

Как видите, программа использует перегруженные операторы:

```c++
title + " я учусь!"; // Добавить текст " я учусь!"
lesson - 'р'; // Удалить букву 'р'
```
В данном случае синтаксис оператора законен, но немного непривычен. Обычно вы используете оператор плюс в выражении, которое возвращает результат, например, как в операторе 

```c++
some_str = title + "текст ";
```

Когда вы определяете оператор, C++ предоставляет вам полную свободу в отношении поведения оператора. Однако, как вы помните, ваша цель при перегрузке операторов состоит в том, чтобы упростить понимание ваших программ. Поэтому следующая программа STR_OVER.CPP немного изменяет предыдущую программу, чтобы позволить ей выполнять операции над переменными типа string, используя синтаксис, который более согласуется со стандартными операторами присваивания:

```c++
#include <iostream> 
#include <cstring>

class string {
 public:
  string(char *); // Конструктор 
  char * operator +(char *) ;
  char * operator -(char);
  void show_string(void);

 private:
  char data[256];
};

string::string(char *str) {
  strcpy(data, str);
}

char * string::operator +(char *str) {
  return(strcat(data, str));
}

char * string::operator -(char letter) {
  char temp[256];
  int i, j;
  
  for (i = 0, j = 0; data[i]; i++)
    if (data[i] 1= letter)
      temp[j++] = data[i];
  
  temp[j] = NULL;
  
  return(strcpy(data, temp));
}

void string::show_string(void) {
  cout << data << endl;
}

void main() {
  string title("Учимся программировать на C++");
  string lesson("Перегрузка операторов");

  title.show_string();
  title = title + " я учусь";
  title.show_string() ;

  lesson.show_string();
  lesson = lesson - '?';
  lesson.show_string();

  return 0;
}
```

Изменив перегруженные операторы плюс и минус таким образом, чтобы они возвращали указатель на символьную строку, программа может теперь использовать эти операторы в привычном для оператора присваивания виде:

```c++
title = title + " учимся программировать!";
lesson = lesson - 'р';
```

### Второй пример

При создании ваших собственных типов данных с помощью классов наиболее общей операцией будет проверка, являются ли два объекта одинаковыми. Используя перегрузку, ваши программы могут перегрузить операторы равенства (==), неравенства (!=) или другие операторы сравнения. Следующая программа COMP_STR.CPP добавляет новый оператор в класс string, который проверяет, равны ли два объекта string. Используя перегрузку операторов, ваши программы могут проверять, содержат ли строковые объекты одинаковые строки, как показано ниже:

```c++
// if (some_string == another_string)

// Ниже приведена реализация программы COMP_STR.CPP:
#include <iostream> 
#include <cstring>

class string {
 public:
  string(char *); // конструктор
  char * operator +(char *);
  char * operator -(char);
  int operator ==(string);
  void show_string(void);

 private:
  char data[256];
};

string::string(char *str) {
  strcpy(data, str);
}

char * string::operator +(char *str) {
  return(strcat(data, str));
}

char * string::operator -(char letter) {
  char temp[256];
  int i, j;

  for (i = 0, j = 0; data[i]; i++)
    if (data[i] 1= letter)
      temp[j++] = data[i];

  temp[j] = NULL;

  return(strcpy(data, temp));
}

int string::operator ==(string str) {
  int i;
  
  for (i = 0; data[i] == str.data[i]; i++)
    if ((data[i] == NULL) && (str.data[i] == NULL))
      return(1); // Равно
  
  return (0); //He равно 
}

void string::show_string(void) {
  cout << data << endl;
}

int main() {
  string title( "Учимся программировать на C++");
  string lesson("Перегрузка операторов");
  string str( "Учимся программировать на C++");

  if (title == lesson)
    std::cout << "title и lesson равны" << std::endl;

  if (str == lesson)
    std::cout << "str и lesson равны" << std::endl;

  if (title == str)
    std::cout << "title и str равны" << std::endl;

  return 0;
}
```

Как видите, перегружая операторы подобным образом, вы упрощаете понимание ваших программ.

## ОПЕРАТОРЫ, КОТОРЫЕ Вbl HE МОЖЕТЕ ПЕРЕГРУЗИТЬ

В общем случае ваши программы могут перегрузить почти все операторы С++. В табл. 24 перечислены операторы, которые C++ не позволяет перегружать.

Таблица 24. Операторы C++, которые ваши программы не могут перегрузить.

Оператор   | Назначение                   | Пример
:--------: | :--------------------------: | :------------------:
`.`        | Выбор элемента               | `object.member`
`.*`       | Указатель на элемент         | `object.*member`
`::`       | Разрешение области видимости | `classname::member`
`?:`       | Условный оператор сравнения  | `с = (а > b) ? а : b`

## ЧТО ВАМ НЕОБХОДИМО ЗНАТЬ

Перегрузка операторов — это возможность назначать новый смысл операторам при использовании их с определенным классом.

Используя перегрузку операторов, вы можете повысить удобочитаемость ваших программ и облегчить их понимание, выражая операции класса более понятным образом.

Из урока 25 вы узнаете, как разделить данные между объектами с помощью элемента static и как использовать методы класса, когда никакие объекты класса не объявляются.

До изучения урока 25 убедитесь, что вы освоили следующее:

1. Чтобы перегрузить оператор, вы должны определить класс, которому оператор будет назначен.

2. Когда вы перегружаете оператор, перегрузка действует только для класса, в котором он определяется. Если программа использует оператор с неклассовыми переменными (например, переменными типа int или float), используется стандартное определение оператора.

3. Чтобы перегрузить оператор класса, используйте ключевое слово C++ operator для определения метода класса, который C++ вызывает каждый раз, когда переменная класса использует оператор.

4. C++ не позволяет вашим программам перегружать оператор выбора элемента (.), оператор указателя на элемент (.*), оператор разрешения области видимости (::) и условный оператор сравнения (?:).